using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Class2Query;

[Generator]
public class SourceGen : ISourceGenerator
{
    private const string AttributeText = @"
using System;

namespace Class2Query.Generated
{
    [AttributeUsage(AttributeTargets.Class)]
    public class IsFilterAttribute : Attribute
    {
    }

    [AttributeUsage(AttributeTargets.Property)]
    public class IncludeIfDefaultAttribute : Attribute
    {
    }
}
";

    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a factory that can create our custom syntax receiver
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver syntaxReceiver)
        {
            return;
        }
        
        var compilation = context.Compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(AttributeText));
        context.AddSource("Class2Query_Attributes.cs", SourceText.From(AttributeText, Encoding.UTF8));

        var isFilterAttributeSymbol = compilation.GetTypeByMetadataName("Class2Query.Generated.IsFilterAttribute");
        var includeIfDefaultAttributeSymbol = compilation.GetTypeByMetadataName("Class2Query.Generated.IncludeIfDefaultAttribute");

        var classSymbols = new List<ISymbol>();
        foreach (var cls in syntaxReceiver.CandidateClasses)
        {
            var model = compilation.GetSemanticModel(cls.SyntaxTree);
            var classSymbol = ModelExtensions.GetDeclaredSymbol(model, cls);
            
            File.WriteAllText("C:\\Temp\\temp.txt", isFilterAttributeSymbol?.Name + "==" + string.Join(",", classSymbol.GetAttributes().Select(ad => ad.AttributeClass.Name)));
            
            if (classSymbol?.GetAttributes().Any(ad => isFilterAttributeSymbol != null && ad.AttributeClass != null && ad.AttributeClass.Name == isFilterAttributeSymbol.Name) ?? false) // todo, weird that  ad.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default) always returns null - see https://github.com/dotnet/roslyn/issues/30248 maybe?
            {
                classSymbols.Add(classSymbol);
            }
        }

        foreach (var classSymbol in classSymbols)
        {
            var properties = compilation.GetTypeByMetadataName(classSymbol.ToDisplayString())
                ?.GetMembers()
                .Where(x => x.Kind == SymbolKind.Property && x.DeclaredAccessibility == Accessibility.Public)
                .Select(x => x as IPropertySymbol)
                .Where(x => x != null)
                .ToArray() ?? Array.Empty<IPropertySymbol>();

            using var writer = new StringWriter();
            using var source = new IndentedTextWriter(writer, "  ");
            source.WriteLine("// <auto-generated />");
            source.WriteLine("using System.Collections.Generic;");
            source.WriteLine("using System.Net.Http;\n");
                        
            source.WriteLine($"using {classSymbol.ContainingNamespace};\n");
            source.WriteLine("namespace Class2Query.Generated");
            source.WriteLine("{");
            source.Indent++;
            source.WriteLine($"public static class {classSymbol.Name}_Class2QueryGenerated");
            source.WriteLine("{");
            source.Indent++;

            source.WriteLine($"public static string ToQuery(this {classSymbol.Name} cls)");
            source.WriteLine("{");
            source.Indent++;

            source.WriteLine("var props = new List<KeyValuePair<string, string>>();");
            
            foreach (var propertySymbol in properties)
            {
                var ifCondition = !propertySymbol?.GetAttributes().Any(ad =>
                    includeIfDefaultAttributeSymbol != null && ad.AttributeClass != null &&
                    ad.AttributeClass.Name == includeIfDefaultAttributeSymbol.Name) ?? false;
                if (ifCondition)
                {
                    source.WriteLine($"if (cls.{propertySymbol.Name} != default)");
                    source.WriteLine("{");
                    source.Indent++;
                }

                var conditionalAccess = propertySymbol.Type.NullableAnnotation == NullableAnnotation.Annotated || propertySymbol.Type.IsReferenceType ? "?" : "";
                source.WriteLine($"props.Add(new KeyValuePair<string, string>(\"{propertySymbol.Name}\", cls.{propertySymbol.Name}{conditionalAccess}.ToString()));");

                if (ifCondition)
                {
                    source.Indent--;
                    source.WriteLine("}");
                }
            }

            source.WriteLine("");
            source.WriteLine("using var content = new FormUrlEncodedContent(props);");
            source.WriteLine("return content.ReadAsStringAsync().Result;");

            source.Indent--;
            source.WriteLine("}");

            source.Indent--;
            source.WriteLine("}");

            source.Indent--;
            source.WriteLine("}");

            context.AddSource($"{classSymbol.Name}_Class2Query.g.cs", SourceText.From(writer.ToString(), Encoding.UTF8));
            File.WriteAllText($"C:\\Temp\\{DateTime.UtcNow.Ticks}-{classSymbol.Name}_Class2Query.g.cs", writer.ToString());
        }
    }
}

public class SyntaxReceiver : ISyntaxReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

    /// <summary>
    /// Called for every syntax node in the compilation, we can inspect the nodes and save any information useful for generation
    /// </summary>
    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        // any field with at least one attribute is a candidate for property generation
        if (syntaxNode is ClassDeclarationSyntax {AttributeLists: {Count: > 0}} classDeclarationSyntax)
        {
            CandidateClasses.Add(classDeclarationSyntax);
        }
    }
}